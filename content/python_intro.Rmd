---
title: "Python - Introduction"
author: "Brendan LE LAIN"
date: "20 janvier 2019"
output: html_document
---

```{r include=FALSE}
knitr::opts_chunk$set(
  comment = "#>",
  out.width = "70%",
  fig.align = 'center',
  fig.width = 6,
  fig.asp = 0.618  # 1 / phi
)
```

# Sources

* <https://docs.python.org/2/tutorial/introduction.html>

## Opérations de base

* commentaire : `#`
* assignation : `=`
* int : `a = 2`
* float : `a = 2.0`
* division classique : `/`

```{python}
print(5/2)
print(5/2.0)
```

* division entière `//`

```{python}
print(5//2)
```

* reste de la division : `%`

```{python}
print(5 % 2)
```

* puissance : `**`

```{python}
print(3**3)
```

* en mode console, le résultat de la dernière opération est stockée dans la variable `_`

## String

* quotes simple ou double

```{python}
print('une chaine l\'agneau')
print("l'agneau")
```

* concaténation : `+`
* répétition : `*`

```{python}
print(3 * "un" + "deux")
```

* string sur plusieurs lignes : `""" ... """`
* 2 strings côte à côte sont concaténés, marche seulement pour des strings (pas des variables). Pratique pour découper des strings longs

```{python}
text = ('Put several strings within parentheses '
        'to have them joined together.')
print(text)
```

* un string est indexable, commence par l'indice 0 :

```{python}
text = "Python"
print(text[0])
print(text[5])
```

* indice négatif pour compter de la fin

```{python}
print(text[-1])
```

* on peut avoir des sous-chaines avec `:`

```{python}
# des défaut pratiques :
print(text[0:2]) # 0 inclut, 2 exclut
print(text[:3])
print(text[-2:])
```

* on ne peut pas changer directement une chaine

```{}
# erreur
# text[2] = "x"   
```

* fonction `len()` pour avoir la taille du string

```{python}
print(len(text))
```

## List

* peut être de type différent, mais c'est souvent le meme type

```{python}
une_list = [1, 2, 3]
```

* peut être indéxé comme les strings 

```{python}
print(une_list[0])  # renvoie un int
print(une_list[:2])  # renvoie une liste
```

* les listes acceptent la concaténation

```{python}
print(une_list + [4, 5])
```

* les listes sont *mutables* (contrairement aux strings) : on peut changer leur valeur

```{python}
une_list[1] = 88
print(une_list)
```

* on peut ajouter un élément avec la *méthode* `append()`

```{python}
une_list.append(100)
print(une_list)
```

* on peut assigner à des *slices*, ça peut changer la taille de la liste ou même la vider complètement

```{python}
letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
print(letters)

letters[2:5] = ['C', 'D', 'E']
print(letters)

letters[2:5] = []
print(letters)

letters[:] = []
print(letters)
```

* on peut aussi utiliser la fonction `len()` pour les listes
```{python}
print(len(letters))
```

* on peut imbriquer les listes

```{python}
a = ['a', 'b', 'c']
n = [1, 2, 3]
x = [a, n]
print(x)

print(x[0])

print(x[0][1])
```

## Programmation

* assignation multiple

```{python}
a, b = 0, 1
print(a)
print(b)
```

* mais on ne peut pas faire 

```{pyhton}
# erreur :
# a, b = 0
```

* les expressions à droite de l'assignation sont évaluées en premier
* l'indentation joue le rôle des accolades

```{python}
# Fibonacci series:
# the sum of two elements defines the next
a, b = 0, 1
while b < 10:
   print(b)
   a, b = b, a+b
```

### if 

* `elif` pour "else if"

```{python}
x = 42
if x < 0:
  x = 0
  print 'Negative changed to zero'
elif x == 0:
  print 'Zero'
elif x == 1:
  print 'Single'
else:
  print 'More'
```

### for 

* Ressemble au `for` de R, on peut itérer aussi bien sur une suite d'entiers que sur une liste ou un string

```{python}
words = ['cat', 'window', 'defenestrate']
for w in words:
  print w, len(w)
```

```{python}
for w in words[:]:  # Loop over a slice copy of the entire list.
  if len(w) > 6:
    words.insert(0, w)
print(words)
```

### La fonction `range()`

* Surtout utile pour les for, permet de générer une séquence d'entiers, renvoie une liste
* avec un seul argument `stop` : liste qui débute à 0 de taille `stop`
* avec 2 arguments `start`, `stop` : commence à `start` inclut, finit à `stop` exclut 
* avec 3 arguments `start`, `stop`, `step`
* tous les arguments doivent être des entiers

```{python}
range(10)
range(5, 10)
range(0, 10, 3)
```

### Définition de fonctions

* avec le mot clé `def`
* on peut mettre sur la première ligne un *docstring* pour documenter la fonction
* une fonction sans `return` renvoie une valeur `None`

```{python}
def fib(n):    # write Fibonacci series up to n
  """Print a Fibonacci series up to n."""
  a, b = 0, 1
  while a < n:
    print a,  # la virgule pour imprimer à la suite (sinon c'est à la ligne)
    a, b = b, a+b

# Now call the function we just defined:
fib(2000)
```

* La même mais en renvoyant le résultat dans une liste :

```{python}
def fib2(n):  # return Fibonacci series up to n
  """Return a list containing the Fibonacci series up to n."""
  result = []
  a, b = 0, 1
  while a < n:
    result.append(a)    # see below
    a, b = b, a+b
  return result
  
print(fib2(100))
```

* une fonction peut avoir un argument par défaut avec `=`






